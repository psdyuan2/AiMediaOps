"""
Context Module - Core state management for Multi-Agent System.

This module defines the Context Object, which serves as the "Single Source of Truth"
for the entire agent execution lifecycle. It follows a layered architecture with
MetaContext, RuntimeContext, and HistoryContext.

Author: Senior Python Backend Architect
"""

import json
import uuid
from datetime import datetime
from typing import Any, Dict, List, Optional, Union
from pydantic import BaseModel, Field, validator


class MetaContext(BaseModel):
    """
    MetaContext - Read-only static context layer.

    Initialized at the start of a task and remains unchanged throughout execution.
    Contains metadata about the execution environment and task configuration.
    """

    trace_id: str = Field(
        description="Unique UUID for the request/task execution trace"
    )
    goal: str = Field(
        description="The user's original natural language instruction"
    )
    environment: str = Field(
        default="dev",
        description="Execution environment (e.g., 'dev', 'prod', 'start')"
    )
    persona: Dict[str, Any] = Field(
        default_factory=dict,
        description="Dynamic persona configuration retrieved from Vector DB"
    )
    created_at: datetime = Field(
        default_factory=datetime.now,
        description="Timestamp when the context was created"
    )

    @validator('trace_id')
    def validate_trace_id(cls, v):
        """Ensure trace_id is a valid UUID string."""
        if not v:
            return str(uuid.uuid4())
        return v

    @validator('environment')
    def validate_environment(cls, v):
        """Validate environment values."""
        valid_envs = {'dev', 'prod', 'start', 'staging'}
        if v not in valid_envs:
            raise ValueError(f"Environment must be one of: {valid_envs}")
        return v


class StepStatus(BaseModel):
    """Represents the status of an execution plan step."""

    step_id: str = Field(description="Unique identifier for the step")
    description: str = Field(description="Description of what the step does")
    agent_name: Optional[str] = Field(default=None, description="Agent responsible for this step")
    status: str = Field(
        default="pending",
        description="Current status: pending, running, success, failed"
    )
    started_at: Optional[datetime] = Field(default=None, description="When the step started")
    completed_at: Optional[datetime] = Field(default=None, description="When the step completed")
    error_message: Optional[str] = Field(default=None, description="Error message if failed")
    result: Optional[Dict[str, Any]] = Field(default=None, description="Step execution result")

    @validator('status')
    def validate_status(cls, v):
        """Validate status values."""
        valid_statuses = {'pending', 'running', 'success', 'failed'}
        if v not in valid_statuses:
            raise ValueError(f"Status must be one of: {valid_statuses}")
        return v


class RuntimeContext(BaseModel):
    """
    RuntimeContext - Dynamic state machine context layer.

    Changes continuously during execution. Tracks the current state of the
    execution plan, shared data between agents, and interrupt conditions.
    """

    execution_plan: List[StepStatus] = Field(
        default_factory=list,
        description="The list of steps generated by the Control Agent"
    )
    current_step_index: int = Field(
        default=0,
        description="Pointer to the current step in execution plan"
    )
    blackboard: Dict[str, Any] = Field(
        default_factory=dict,
        description="Shared memory space for agents to exchange data"
    )
    interrupt_flags: Dict[str, bool] = Field(
        default_factory=dict,
        description="Interrupt flags (e.g., login_required, captcha_detected)"
    )
    is_paused: bool = Field(
        default=False,
        description="Whether the execution is currently paused"
    )
    is_completed: bool = Field(
        default=False,
        description="Whether the execution has completed"
    )

    def add_step(self, description: str, agent_name: Optional[str] = None) -> str:
        """
        Add a new step to the execution plan.

        Args:
            description: Description of the step
            agent_name: Agent responsible for the step

        Returns:
            Step ID
        """
        step_id = str(uuid.uuid4())
        step = StepStatus(
            step_id=step_id,
            description=description,
            agent_name=agent_name
        )
        self.execution_plan.append(step)
        return step_id

    def get_current_step(self) -> Optional[StepStatus]:
        """Get the current step in execution plan."""
        if 0 <= self.current_step_index < len(self.execution_plan):
            return self.execution_plan[self.current_step_index]
        return None

    def advance_to_next_step(self) -> bool:
        """Move to the next step in execution plan."""
        if self.current_step_index < len(self.execution_plan) - 1:
            self.current_step_index += 1
            return True
        return False

    def set_step_status(self, step_id: str, status: str, error_message: Optional[str] = None, result: Optional[Dict[str, Any]] = None):
        """Update the status of a specific step."""
        for step in self.execution_plan:
            if step.step_id == step_id:
                step.status = status
                if status == "running" and not step.started_at:
                    step.started_at = datetime.now()
                elif status in {"success", "failed"}:
                    step.completed_at = datetime.now()
                    step.error_message = error_message
                    step.result = result
                break


class ActionLog(BaseModel):
    """Represents a single action in the execution history."""

    timestamp: datetime = Field(default_factory=datetime.now)
    agent_name: str = Field(description="Name of the agent performing the action")
    action: str = Field(description="Description of the action performed")
    result: Optional[Dict[str, Any]] = Field(default=None, description="Action result")
    duration_ms: Optional[int] = Field(default=None, description="Action duration in milliseconds")


class HistoryContext(BaseModel):
    """
    HistoryContext - Logging context layer.

    Records the journey of execution with chronological logs and memory.
    """

    action_log: List[ActionLog] = Field(
        default_factory=list,
        description="Chronological log of actions taken"
    )
    short_term_memory: List[str] = Field(
        default_factory=list,
        description="Key reasoning steps or Chain-of-Thought summaries"
    )
    last_checkpoint_at: Optional[datetime] = Field(
        default=None,
        description="Timestamp of last checkpoint"
    )

    def add_action_log(self, agent_name: str, action: str, result: Optional[Dict[str, Any]] = None, duration_ms: Optional[int] = None):
        """Add a new action to the log."""
        log_entry = ActionLog(
            agent_name=agent_name,
            action=action,
            result=result,
            duration_ms=duration_ms
        )
        self.action_log.append(log_entry)

    def add_memory(self, memory_entry: str):
        """Add an entry to short-term memory."""
        self.short_term_memory.append(memory_entry)

    def get_recent_actions(self, limit: int = 10) -> List[ActionLog]:
        """Get the most recent actions from the log."""
        return self.action_log[-limit:] if limit > 0 else self.action_log


class Context(BaseModel):
    """
    Main Context class - Single Source of Truth for agent execution.

    Combines three layers: MetaContext (static), RuntimeContext (dynamic),
    and HistoryContext (logging). Provides helper methods for state management.
    """

    meta: MetaContext = Field(description="Static meta-context layer")
    runtime: RuntimeContext = Field(description="Dynamic runtime context layer")
    history: HistoryContext = Field(description="Historical context layer")

    class Config:
        """Pydantic configuration."""
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }

    @classmethod
    def create_new(cls, goal: str, environment: str = "dev", persona: Optional[Dict[str, Any]] = None) -> "Context":
        """
        Factory method to create a new Context instance.

        Args:
            goal: The user's original goal/instruction
            environment: Execution environment
            persona: Persona configuration

        Returns:
            New Context instance
        """
        meta = MetaContext(
            trace_id=str(uuid.uuid4()),
            goal=goal,
            environment=environment,
            persona=persona or {}
        )

        return cls(
            meta=meta,
            runtime=RuntimeContext(),
            history=HistoryContext()
        )

    # Serialization Methods
    def to_json(self) -> str:
        """
        Serialize context to JSON string.

        Returns:
            JSON string representation
        """
        return self.model_dump_json(indent=2)

    @classmethod
    def from_json(cls, json_str: str) -> "Context":
        """
        Deserialize context from JSON string.

        Args:
            json_str: JSON string representation

        Returns:
            Context instance
        """
        return cls.model_validate_json(json_str)

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert context to dictionary.

        Returns:
            Dictionary representation
        """
        return self.model_dump()

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Context":
        """
        Create context from dictionary.

        Args:
            data: Dictionary representation

        Returns:
            Context instance
        """
        return cls.model_validate(data)

    # Blackboard Access Methods
    def set_shared_data(self, key: str, value: Any):
        """
        Store data in the shared blackboard.

        Args:
            key: Data key
            value: Data value
        """
        self.runtime.blackboard[key] = value

    def get_shared_data(self, key: str, default: Any = None) -> Any:
        """
        Retrieve data from the shared blackboard.

        Args:
            key: Data key
            default: Default value if key not found

        Returns:
            Retrieved data or default value
        """
        return self.runtime.blackboard.get(key, default)

    def remove_shared_data(self, key: str) -> bool:
        """
        Remove data from the shared blackboard.

        Args:
            key: Data key

        Returns:
            True if key existed and was removed, False otherwise
        """
        return self.runtime.blackboard.pop(key, None) is not None

    def clear_blackboard(self):
        """Clear all data from the shared blackboard."""
        self.runtime.blackboard.clear()

    # Logging Methods
    def log_action(self, agent_name: str, action: str, result: Optional[Dict[str, Any]] = None, duration_ms: Optional[int] = None):
        """
        Log an action to the history.

        Args:
            agent_name: Name of the agent
            action: Action description
            result: Action result
            duration_ms: Action duration in milliseconds
        """
        self.history.add_action_log(agent_name, action, result, duration_ms)

    def add_memory(self, memory_entry: str):
        """
        Add an entry to short-term memory.

        Args:
            memory_entry: Memory entry text
        """
        self.history.add_memory(memory_entry)

    # Interrupt Flag Methods
    def set_interrupt_flag(self, flag: str, value: bool):
        """
        Set an interrupt flag.

        Args:
            flag: Flag name
            value: Flag value
        """
        self.runtime.interrupt_flags[flag] = value

    def get_interrupt_flag(self, flag: str) -> bool:
        """
        Get the value of an interrupt flag.

        Args:
            flag: Flag name

        Returns:
            Flag value (default: False)
        """
        return self.runtime.interrupt_flags.get(flag, False)

    def clear_interrupt_flag(self, flag: str):
        """
        Clear an interrupt flag.

        Args:
            flag: Flag name
        """
        self.runtime.interrupt_flags.pop(flag, None)

    # Snapshot and Checkpoint Methods
    def create_snapshot(self, include_history: bool = True) -> Dict[str, Any]:
        """
        Create a snapshot of the current context state.

        Args:
            include_history: Whether to include action log in snapshot

        Returns:
            Snapshot dictionary
        """
        snapshot = {
            "meta": self.meta.model_dump(),
            "runtime": self.runtime.model_dump(),
            "snapshot_taken_at": datetime.now().isoformat()
        }

        if include_history:
            snapshot["history"] = self.history.model_dump()

        return snapshot

    def restore_from_snapshot(self, snapshot: Dict[str, Any]):
        """
        Restore context from a snapshot.

        Args:
            snapshot: Snapshot dictionary
        """
        if "meta" in snapshot:
            self.meta = MetaContext.model_validate(snapshot["meta"])
        if "runtime" in snapshot:
            self.runtime = RuntimeContext.model_validate(snapshot["runtime"])
        if "history" in snapshot:
            self.history = HistoryContext.model_validate(snapshot["history"])

    def create_checkpoint(self) -> str:
        """
        Create a checkpoint and mark it in history.

        Returns:
            Checkpoint ID
        """
        checkpoint_id = str(uuid.uuid4())
        self.history.last_checkpoint_at = datetime.now()
        self.set_shared_data(f"checkpoint_{checkpoint_id}", self.create_snapshot())
        return checkpoint_id

    # Utility Methods
    def get_execution_summary(self) -> Dict[str, Any]:
        """
        Get a summary of the execution state.

        Returns:
            Execution summary dictionary
        """
        total_steps = len(self.runtime.execution_plan)
        completed_steps = sum(1 for step in self.runtime.execution_plan if step.status == "success")
        failed_steps = sum(1 for step in self.runtime.execution_plan if step.status == "failed")

        return {
            "trace_id": self.meta.trace_id,
            "goal": self.meta.goal,
            "environment": self.meta.environment,
            "total_steps": total_steps,
            "completed_steps": completed_steps,
            "failed_steps": failed_steps,
            "current_step_index": self.runtime.current_step_index,
            "is_paused": self.runtime.is_paused,
            "is_completed": self.runtime.is_completed,
            "total_actions": len(self.history.action_log),
            "memory_entries": len(self.history.short_term_memory),
            "blackboard_size": len(self.runtime.blackboard),
            "created_at": self.meta.created_at.isoformat(),
            "last_checkpoint_at": self.history.last_checkpoint_at.isoformat() if self.history.last_checkpoint_at else None
        }

    def __str__(self) -> str:
        """String representation of the context."""
        return f"Context(trace_id={self.meta.trace_id}, goal='{self.meta.goal[:50]}...', steps={len(self.runtime.execution_plan)})"

    def __repr__(self) -> str:
        """Detailed string representation of the context."""
        return f"Context(trace_id='{self.meta.trace_id}', goal='{self.meta.goal}', environment='{self.meta.environment}', current_step={self.runtime.current_step_index}, total_steps={len(self.runtime.execution_plan)})"